# Redis 기반 TOP10 인기 상품 조회 시스템 설계 및 개발 보고서


1. 개요
   🔍 목적
   상품 주문 데이터를 기반으로 실시간 인기 상품 TOP10을 사용자에게 제공하는 기능을 구현한다.

높은 요청 처리 성능과 정확한 순위 계산을 위해 Redis Sorted Set(ZSet)을 활용한다.

2. 시스템 설계
   🧱 핵심 설계 요소

| 항목             | 내용                                     |
|------------------|----------------------------------------|
| 데이터 저장소     | Redis (Sorted Set, ZSet)               |
| 기준 점수         | 상품별 주문 수량 합계                           |
| 랭킹 키           | `ranking:daily:{yyyy-MM-dd}` 형식의 일자별 키 |
| TTL 설정         | 2일 (일간 기준 데이터 자동 만료)                   |
| 요청 API         | `GET /api/v1/products/top?size=N`      |
| 정렬 기준         | 점수 내림차순 (`ZREVRANGE`)                  |
| 스코어 누적 시점 | 결제 완료 시 `ZINCRBY` 사용하여 주문수량만큼 score 증가 |
| 랭킹 상품 정보     | Redis에서는 ID만 관리, 실제 상품 정보는 DB에서 매핑     |

3. 개발 상세
   ✅ 주문 완료 시 점수 누적
   OrderEntity가 PAID로 변경되면, 포함된 모든 OrderProductEntity에 대해 Redis ZSet 점수 증가

예시 코드:

```java
redisTemplate.opsForZSet().incrementScore("ranking:daily:2025-05-11", productId.toString(), quantity);
```
✅ 일간 인기 상품 조회

Redis에서 상위 N개 상품 ID 조회 (ZREVRANGE)

DB에서 해당 ID들의 상품 정보 조회

DTO 변환 후 응답 반환

4. 성능 및 장점

   | 항목         | 효과                                                                 |
   |--------------|----------------------------------------------------------------------|
   | 응답 속도     | Redis에서 인기 상품 ID 조회는 평균 1~2ms 이내                         |
   | 데이터 일관성 | 주문 → 점수 증가 흐름을 트랜잭션 후에 분리하여 비동기화 가능           |
   | 확장성        | 일간 외에도 주간/월간 키 추가 가능 (`ranking:weekly:{yyyy-WW}` 등)     |
   | 정렬 정확도   | 점수 기반 내림차순 정렬로 사용자 신뢰도 상승                           |



5. 테스트 결과
   ✅ E2E 테스트를 통해 상품 주문 시 Redis 점수가 실제로 증가하는지 검증

✅ /api/v1/products/top API 호출 시 Redis 점수 순서대로 정렬된 상품이 응답됨

✅ 상품이 10개 이상일 때 정확히 size만큼 반환되는지 확인

6. 회고 및 개선 방향
   👍 잘한 점
   Redis ZSet을 통해 정렬된 데이터를 빠르게 제공 가능

서비스/레포지토리 분리 설계를 통해 DIP 원칙을 지켜 유지보수가 쉬움

테스트 코드에서 Redis 점수까지 검증하여 안정성 확보

⚠️ 아쉬운 점
TTL 설정 시 중복 호출로 인해 expire가 반복 설정됨 (최적화 여지 있음)

Redis 장애 대비 fallback 로직이 아직 없음 → 추후 DB 기반 랭킹으로 대체 가능성 고려 필요

Redis에 저장된 데이터는 실시간성이 강하지만, 데이터 동기화 실패 시 보완 필요